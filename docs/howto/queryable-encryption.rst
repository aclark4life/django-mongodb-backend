================================
Configuring Queryable Encryption
================================

.. versionadded:: 5.2.3

:doc:`manual:core/queryable-encryption` is a powerful MongoDB feature that
allows you to encrypt sensitive fields in your database while still supporting
queries on that encrypted data.

This section will guide you through the process of configuring Queryable
Encryption in your Django project.

.. admonition:: MongoDB requirements

    Queryable Encryption can be used with MongoDB replica sets or sharded
    clusters running version 7.0 or later. Standalone instances are not
    supported. The :ref:`manual:qe-compatibility-reference` table summarizes
    which MongoDB server products support Queryable Encryption.

Installation
============

In addition to Django MongoDB Backend's regular :doc:`installation
</intro/install>` and :doc:`configuration </intro/configure>` steps, Queryable
Encryption has additional Python dependencies:

.. code-block:: console

    $ pip install django-mongodb-backend[encryption]

.. _qe-configuring-databases-setting:

Configuring the ``DATABASES`` setting
=====================================

In addition to the :ref:`database settings <configuring-databases-setting>`
required to use Django MongoDB Backend, Queryable Encryption requires
configuring a separate database connection that uses use PyMongo's
:class:`~pymongo.encryption_options.AutoEncryptionOpts`.

Here's a sample configuration using a local KMS provider::

    from pymongo.encryption_options import AutoEncryptionOpts

    DATABASES = {
        "default": {
            "ENGINE": "django_mongodb_backend",
            "HOST": "mongodb+srv://cluster0.example.mongodb.net",
            "NAME": "my_database",
            # ...
        },
        "encrypted": {
            "ENGINE": "django_mongodb_backend",
            "HOST": "mongodb+srv://cluster0.example.mongodb.net",
            "NAME": "my_encrypted_database",
            # ...
            "OPTIONS": {
                "auto_encryption_opts": AutoEncryptionOpts(
                    key_vault_namespace="my_encrypted_database.__keyVault",
                    kms_providers={
                        "local": {
                            # Generated by os.urandom(96)
                            "key": (
                                b'-\xc3\x0c\xe3\x93\xc3\x8b\xc0\xf8\x12\xc5#b'
                                b'\x19\xf3\xbc\xccR\xc8\xedI\xda\\ \xfb\x9cB'
                                b'\x7f\xab5\xe7\xb5\xc9x\xb8\xd4d\xba\xdc\x9c'
                                b'\x9a\xdb9J]\xe6\xce\x104p\x079q.=\xeb\x9dK*'
                                b'\x97\xea\xf8\x1e\xc3\xd49K\x18\x81\xc3\x1a"'
                                b'\xdc\x00U\xc4u"X\xe7xy\xa5\xb2\x0e\xbc\xd6+-'
                                b'\x80\x03\xef\xc2\xc4\x9bU'
                        },
                    },
                )
            },
        },
    }

``key_vault_namespace`` specifies where to store the data encryption keys.
The database name of the key vault must be the same as in ``"NAME"``. The
vault's collection name can be whatever you wish, but by convention, it's often
``__keyVault``.

.. _qe-configuring-database-routers-setting:

Configuring the ``DATABASE_ROUTERS`` setting
============================================

Similar to configuring the :ref:`DATABASE_ROUTERS
<configuring-database-routers-setting>` setting for
:doc:`embedded models </topics/embedded-models>`, Queryable Encryption requires
a :setting:`DATABASE_ROUTERS` setting to route database operations to the
encrypted database.

The following example shows how to configure a router for the ``"myapp"``
application that routes database operations to the encrypted database for all
models in that application::

    # myapp/routers.py
    class EncryptedRouter:
        def allow_migrate(self, db, app_label, model_name=None, **hints):
            if app_label == "myapp":
                return db == "encrypted"
            # Prevent migrations on the encrypted database for other apps
            if db == "encrypted":
                return False
            return None

        def db_for_read(self, model, **hints):
            if model._meta.app_label == "myapp":
                return "encrypted"
            return None

        db_for_write = db_for_read

Then in your Django settings, add the custom database router to the
:setting:`django:DATABASE_ROUTERS` setting::

    # settings.py
    DATABASE_ROUTERS = [
        "django_mongodb_backend.routers.MongoRouter",
        "myapp.routers.EncryptedRouter",
    ]

.. _qe-configuring-kms:

Configuring the Key Management Service (KMS)
============================================

A local KMS provider with a hardcoded key is suitable for local development and
testing, but production environment, you should securely :ref:`store and manage your
encryption keys <manual:qe-fundamentals-kms-providers>`.

To use Queryable Encryption, you must configure a Key Management Service (KMS)
to store and manage the encryption keys used to encrypt and decrypt data.

There are two primary configuration points:

#. The ``kms_providers`` parameter of
   :class:`~pymongo.encryption_options.AutoEncryptionOpts` (see the
   ``kms_providers`` parameter in
   :class:`~pymongo.encryption_options.AutoEncryptionOpts` for the available
   providers (``aws``, ``azure``, ``gcp``, etc.) and provider options).

#. The :setting:`KMS_CREDENTIALS <DATABASE-KMS-CREDENTIALS>` inner option of
   :setting:`DATABASES`. The keys for each provider are documented under the
   ``master_key`` parameter of
   :meth:`~pymongo.encryption.ClientEncryption.create_data_key`.

Here's an example of KMS configuration with ``aws``::

    from pymongo.encryption_options import AutoEncryptionOpts

    DATABASES = {
        "encrypted": {
            # ...
            "OPTIONS": {
                "auto_encryption_opts": AutoEncryptionOpts(
                    # ...
                    kms_providers={
                        "aws": {
                            "accessKeyId": "your-access-key-id",
                            "secretAccessKey": "your-secret-access-key",
                        },
                    },
                ),
            },
            "KMS_CREDENTIALS": {
                "aws": {
                    "key": "...",  # Amazon Resource Name
                    "region": "...",  # AWS region
                },
            },
        },
    }

(TODO: If there's a use case for multiple providers, motivate with a use case
and add a test.)

If you've configured multiple KMS providers, you must define logic to determine
the provider for each model in your :ref:`database router
<qe-configuring-database-routers-setting>`::

    class EncryptedRouter:
        # ...
        def kms_provider(self, model, **hints):
            return "aws"

.. _qe-configuring-encrypted-fields-map:

Configuring the ``encrypted_fields_map`` option
===============================================

Encryption keys are created when you :ref:`run migrations for models that have
encrypted fields <qe-migrations>`.

To see the encrypted fields map for your models (which includes the encryption
key IDs), run the :djadmin:`showencryptedfieldsmap` command::

    $ python manage.py showencryptedfieldsmap --database encrypted

In a production environment, it's recommended to include this map in your
settings to protect against a malicious server advertising a false encrypted
fields map::

    from bson import json_util
    from pymongo.encryption_options import AutoEncryptionOpts

    DATABASES = {
        "encrypted": {
            # ...
            "OPTIONS": {
                "auto_encryption_opts": AutoEncryptionOpts(
                    # ...
                    encrypted_fields_map=json_util.loads(
                        """{
                        "encrypt_patient": {
                            "fields": [
                                 {
                                     "bsonType": "string",
                                     "path": "patient_record.ssn",
                                     "keyId": {
                                          "$binary": {
                                              "base64": "2MA29LaARIOqymYHGmi2mQ==",
                                              "subType": "04"
                                          }
                                     },
                                     "queries": {
                                         "queryType": "equality"
                                     }
                                 },
                            ]
                        }}"""
                    ),
                ),
            },
        },
    }

Configuring the Automatic Encryption Shared Library
===================================================

The :ref:`manual:qe-reference-shared-library` is a preferred alternative to
:ref:`manual:qe-mongocryptd` and does not require you to start another process
to perform automatic encryption.

In practice, if you use Atlas or Enterprise MongoDB, ``mongocryptd`` is already
configured for you, however in such cases the shared library is still
recommended for use with Queryable Encryption.

You can :ref:`download the shared library
<manual:qe-csfle-shared-library-download>` from the
:ref:`manual:enterprise-official-packages`. The shared library is
platformâ€‘specific. Make sure to download the correct version for your operating
system and architecture.

To configure it in your Django settings, use
:class:`~pymongo.encryption_options.AutoEncryptionOpts`\'s
``crypt_shared_lib_path`` parameter::

    from pymongo.encryption_options import AutoEncryptionOpts

    DATABASES = {
        "encrypted": {
            # ...
            "OPTIONS": {
                "auto_encryption_opts": AutoEncryptionOpts(
                    # ...
                    crypt_shared_lib_path="/path/to/mongo_crypt_shared_v1.dylib",
                )
            },
        },
    }

.. admonition:: Dynamic library path configuration

    You may also need to configure an environment variable so that your system
    can locate the library:

    +---------------+---------------------------------+
    | **Platform**  | **Environment Variable**        |
    +---------------+---------------------------------+
    | Windows       | ``PATH``                        |
    +---------------+---------------------------------+
    | macOS         | ``DYLD_FALLBACK_LIBRARY_PATH``  |
    +---------------+---------------------------------+
    | Linux         | ``LD_LIBRARY_PATH``             |
    +---------------+---------------------------------+

    For example, on macOS you can set the ``DYLD_FALLBACK_LIBRARY_PATH``
    environment variable in your shell before starting your Django application::

        $ export DYLD_FALLBACK_LIBRARY_PATH="/path/to/mongo_crypt_shared_v1.dylib:$DYLD_FALLBACK_LIBRARY_PATH"

You are now ready to :doc:`start developing applications
</topics/queryable-encryption>` with Queryable Encryption!
